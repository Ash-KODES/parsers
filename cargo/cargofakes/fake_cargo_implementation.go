// Code generated by counterfeiter. DO NOT EDIT.
package cargofakes

import (
	"sync"

	"github.com/opensbom-generator/parsers/cargo"
	"github.com/opensbom-generator/parsers/meta"
)

type FakeCargoImplementation struct {
	ConvertCargoPackageToMetaPackageStub        func(*cargo.Package) meta.Package
	convertCargoPackageToMetaPackageMutex       sync.RWMutex
	convertCargoPackageToMetaPackageArgsForCall []struct {
		arg1 *cargo.Package
	}
	convertCargoPackageToMetaPackageReturns struct {
		result1 meta.Package
	}
	convertCargoPackageToMetaPackageReturnsOnCall map[int]struct {
		result1 meta.Package
	}
	ConvertPackagesToModulesListStub        func([]*cargo.Package) (map[string]*meta.Package, error)
	convertPackagesToModulesListMutex       sync.RWMutex
	convertPackagesToModulesListArgsForCall []struct {
		arg1 []*cargo.Package
	}
	convertPackagesToModulesListReturns struct {
		result1 map[string]*meta.Package
		result2 error
	}
	convertPackagesToModulesListReturnsOnCall map[int]struct {
		result1 map[string]*meta.Package
		result2 error
	}
	GetCargoMetadataStub        func(string) (cargo.Metadata, error)
	getCargoMetadataMutex       sync.RWMutex
	getCargoMetadataArgsForCall []struct {
		arg1 string
	}
	getCargoMetadataReturns struct {
		result1 cargo.Metadata
		result2 error
	}
	getCargoMetadataReturnsOnCall map[int]struct {
		result1 cargo.Metadata
		result2 error
	}
	GetCargoMetadataIfNeededStub        func(*cargo.Mod, string) (*cargo.Metadata, error)
	getCargoMetadataIfNeededMutex       sync.RWMutex
	getCargoMetadataIfNeededArgsForCall []struct {
		arg1 *cargo.Mod
		arg2 string
	}
	getCargoMetadataIfNeededReturns struct {
		result1 *cargo.Metadata
		result2 error
	}
	getCargoMetadataIfNeededReturnsOnCall map[int]struct {
		result1 *cargo.Metadata
		result2 error
	}
	GetPackageDependenciesStub        func(*cargo.Metadata, string) ([]*cargo.Package, error)
	getPackageDependenciesMutex       sync.RWMutex
	getPackageDependenciesArgsForCall []struct {
		arg1 *cargo.Metadata
		arg2 string
	}
	getPackageDependenciesReturns struct {
		result1 []*cargo.Package
		result2 error
	}
	getPackageDependenciesReturnsOnCall map[int]struct {
		result1 []*cargo.Package
		result2 error
	}
	GetRootModuleStub        func(*cargo.Metadata, string) (meta.Package, error)
	getRootModuleMutex       sync.RWMutex
	getRootModuleArgsForCall []struct {
		arg1 *cargo.Metadata
		arg2 string
	}
	getRootModuleReturns struct {
		result1 meta.Package
		result2 error
	}
	getRootModuleReturnsOnCall map[int]struct {
		result1 meta.Package
		result2 error
	}
	GetRootProjectNameStub        func(string) (string, error)
	getRootProjectNameMutex       sync.RWMutex
	getRootProjectNameArgsForCall []struct {
		arg1 string
	}
	getRootProjectNameReturns struct {
		result1 string
		result2 error
	}
	getRootProjectNameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	PopulateDependenciesStub        func(*cargo.Metadata, *meta.Package, bool, *map[string]*meta.Package) error
	populateDependenciesMutex       sync.RWMutex
	populateDependenciesArgsForCall []struct {
		arg1 *cargo.Metadata
		arg2 *meta.Package
		arg3 bool
		arg4 *map[string]*meta.Package
	}
	populateDependenciesReturns struct {
		result1 error
	}
	populateDependenciesReturnsOnCall map[int]struct {
		result1 error
	}
	ReadConfigStub        func(string) (*cargo.Config, error)
	readConfigMutex       sync.RWMutex
	readConfigArgsForCall []struct {
		arg1 string
	}
	readConfigReturns struct {
		result1 *cargo.Config
		result2 error
	}
	readConfigReturnsOnCall map[int]struct {
		result1 *cargo.Config
		result2 error
	}
	ReadLockFileStub        func(string) (*cargo.LockFile, error)
	readLockFileMutex       sync.RWMutex
	readLockFileArgsForCall []struct {
		arg1 string
	}
	readLockFileReturns struct {
		result1 *cargo.LockFile
		result2 error
	}
	readLockFileReturnsOnCall map[int]struct {
		result1 *cargo.LockFile
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCargoImplementation) ConvertCargoPackageToMetaPackage(arg1 *cargo.Package) meta.Package {
	fake.convertCargoPackageToMetaPackageMutex.Lock()
	ret, specificReturn := fake.convertCargoPackageToMetaPackageReturnsOnCall[len(fake.convertCargoPackageToMetaPackageArgsForCall)]
	fake.convertCargoPackageToMetaPackageArgsForCall = append(fake.convertCargoPackageToMetaPackageArgsForCall, struct {
		arg1 *cargo.Package
	}{arg1})
	stub := fake.ConvertCargoPackageToMetaPackageStub
	fakeReturns := fake.convertCargoPackageToMetaPackageReturns
	fake.recordInvocation("ConvertCargoPackageToMetaPackage", []interface{}{arg1})
	fake.convertCargoPackageToMetaPackageMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCargoImplementation) ConvertCargoPackageToMetaPackageCallCount() int {
	fake.convertCargoPackageToMetaPackageMutex.RLock()
	defer fake.convertCargoPackageToMetaPackageMutex.RUnlock()
	return len(fake.convertCargoPackageToMetaPackageArgsForCall)
}

func (fake *FakeCargoImplementation) ConvertCargoPackageToMetaPackageCalls(stub func(*cargo.Package) meta.Package) {
	fake.convertCargoPackageToMetaPackageMutex.Lock()
	defer fake.convertCargoPackageToMetaPackageMutex.Unlock()
	fake.ConvertCargoPackageToMetaPackageStub = stub
}

func (fake *FakeCargoImplementation) ConvertCargoPackageToMetaPackageArgsForCall(i int) *cargo.Package {
	fake.convertCargoPackageToMetaPackageMutex.RLock()
	defer fake.convertCargoPackageToMetaPackageMutex.RUnlock()
	argsForCall := fake.convertCargoPackageToMetaPackageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCargoImplementation) ConvertCargoPackageToMetaPackageReturns(result1 meta.Package) {
	fake.convertCargoPackageToMetaPackageMutex.Lock()
	defer fake.convertCargoPackageToMetaPackageMutex.Unlock()
	fake.ConvertCargoPackageToMetaPackageStub = nil
	fake.convertCargoPackageToMetaPackageReturns = struct {
		result1 meta.Package
	}{result1}
}

func (fake *FakeCargoImplementation) ConvertCargoPackageToMetaPackageReturnsOnCall(i int, result1 meta.Package) {
	fake.convertCargoPackageToMetaPackageMutex.Lock()
	defer fake.convertCargoPackageToMetaPackageMutex.Unlock()
	fake.ConvertCargoPackageToMetaPackageStub = nil
	if fake.convertCargoPackageToMetaPackageReturnsOnCall == nil {
		fake.convertCargoPackageToMetaPackageReturnsOnCall = make(map[int]struct {
			result1 meta.Package
		})
	}
	fake.convertCargoPackageToMetaPackageReturnsOnCall[i] = struct {
		result1 meta.Package
	}{result1}
}

func (fake *FakeCargoImplementation) ConvertPackagesToModulesList(arg1 []*cargo.Package) (map[string]*meta.Package, error) {
	var arg1Copy []*cargo.Package
	if arg1 != nil {
		arg1Copy = make([]*cargo.Package, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.convertPackagesToModulesListMutex.Lock()
	ret, specificReturn := fake.convertPackagesToModulesListReturnsOnCall[len(fake.convertPackagesToModulesListArgsForCall)]
	fake.convertPackagesToModulesListArgsForCall = append(fake.convertPackagesToModulesListArgsForCall, struct {
		arg1 []*cargo.Package
	}{arg1Copy})
	stub := fake.ConvertPackagesToModulesListStub
	fakeReturns := fake.convertPackagesToModulesListReturns
	fake.recordInvocation("ConvertPackagesToModulesList", []interface{}{arg1Copy})
	fake.convertPackagesToModulesListMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCargoImplementation) ConvertPackagesToModulesListCallCount() int {
	fake.convertPackagesToModulesListMutex.RLock()
	defer fake.convertPackagesToModulesListMutex.RUnlock()
	return len(fake.convertPackagesToModulesListArgsForCall)
}

func (fake *FakeCargoImplementation) ConvertPackagesToModulesListCalls(stub func([]*cargo.Package) (map[string]*meta.Package, error)) {
	fake.convertPackagesToModulesListMutex.Lock()
	defer fake.convertPackagesToModulesListMutex.Unlock()
	fake.ConvertPackagesToModulesListStub = stub
}

func (fake *FakeCargoImplementation) ConvertPackagesToModulesListArgsForCall(i int) []*cargo.Package {
	fake.convertPackagesToModulesListMutex.RLock()
	defer fake.convertPackagesToModulesListMutex.RUnlock()
	argsForCall := fake.convertPackagesToModulesListArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCargoImplementation) ConvertPackagesToModulesListReturns(result1 map[string]*meta.Package, result2 error) {
	fake.convertPackagesToModulesListMutex.Lock()
	defer fake.convertPackagesToModulesListMutex.Unlock()
	fake.ConvertPackagesToModulesListStub = nil
	fake.convertPackagesToModulesListReturns = struct {
		result1 map[string]*meta.Package
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) ConvertPackagesToModulesListReturnsOnCall(i int, result1 map[string]*meta.Package, result2 error) {
	fake.convertPackagesToModulesListMutex.Lock()
	defer fake.convertPackagesToModulesListMutex.Unlock()
	fake.ConvertPackagesToModulesListStub = nil
	if fake.convertPackagesToModulesListReturnsOnCall == nil {
		fake.convertPackagesToModulesListReturnsOnCall = make(map[int]struct {
			result1 map[string]*meta.Package
			result2 error
		})
	}
	fake.convertPackagesToModulesListReturnsOnCall[i] = struct {
		result1 map[string]*meta.Package
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) GetCargoMetadata(arg1 string) (cargo.Metadata, error) {
	fake.getCargoMetadataMutex.Lock()
	ret, specificReturn := fake.getCargoMetadataReturnsOnCall[len(fake.getCargoMetadataArgsForCall)]
	fake.getCargoMetadataArgsForCall = append(fake.getCargoMetadataArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetCargoMetadataStub
	fakeReturns := fake.getCargoMetadataReturns
	fake.recordInvocation("GetCargoMetadata", []interface{}{arg1})
	fake.getCargoMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCargoImplementation) GetCargoMetadataCallCount() int {
	fake.getCargoMetadataMutex.RLock()
	defer fake.getCargoMetadataMutex.RUnlock()
	return len(fake.getCargoMetadataArgsForCall)
}

func (fake *FakeCargoImplementation) GetCargoMetadataCalls(stub func(string) (cargo.Metadata, error)) {
	fake.getCargoMetadataMutex.Lock()
	defer fake.getCargoMetadataMutex.Unlock()
	fake.GetCargoMetadataStub = stub
}

func (fake *FakeCargoImplementation) GetCargoMetadataArgsForCall(i int) string {
	fake.getCargoMetadataMutex.RLock()
	defer fake.getCargoMetadataMutex.RUnlock()
	argsForCall := fake.getCargoMetadataArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCargoImplementation) GetCargoMetadataReturns(result1 cargo.Metadata, result2 error) {
	fake.getCargoMetadataMutex.Lock()
	defer fake.getCargoMetadataMutex.Unlock()
	fake.GetCargoMetadataStub = nil
	fake.getCargoMetadataReturns = struct {
		result1 cargo.Metadata
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) GetCargoMetadataReturnsOnCall(i int, result1 cargo.Metadata, result2 error) {
	fake.getCargoMetadataMutex.Lock()
	defer fake.getCargoMetadataMutex.Unlock()
	fake.GetCargoMetadataStub = nil
	if fake.getCargoMetadataReturnsOnCall == nil {
		fake.getCargoMetadataReturnsOnCall = make(map[int]struct {
			result1 cargo.Metadata
			result2 error
		})
	}
	fake.getCargoMetadataReturnsOnCall[i] = struct {
		result1 cargo.Metadata
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) GetCargoMetadataIfNeeded(arg1 *cargo.Mod, arg2 string) (*cargo.Metadata, error) {
	fake.getCargoMetadataIfNeededMutex.Lock()
	ret, specificReturn := fake.getCargoMetadataIfNeededReturnsOnCall[len(fake.getCargoMetadataIfNeededArgsForCall)]
	fake.getCargoMetadataIfNeededArgsForCall = append(fake.getCargoMetadataIfNeededArgsForCall, struct {
		arg1 *cargo.Mod
		arg2 string
	}{arg1, arg2})
	stub := fake.GetCargoMetadataIfNeededStub
	fakeReturns := fake.getCargoMetadataIfNeededReturns
	fake.recordInvocation("GetCargoMetadataIfNeeded", []interface{}{arg1, arg2})
	fake.getCargoMetadataIfNeededMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCargoImplementation) GetCargoMetadataIfNeededCallCount() int {
	fake.getCargoMetadataIfNeededMutex.RLock()
	defer fake.getCargoMetadataIfNeededMutex.RUnlock()
	return len(fake.getCargoMetadataIfNeededArgsForCall)
}

func (fake *FakeCargoImplementation) GetCargoMetadataIfNeededCalls(stub func(*cargo.Mod, string) (*cargo.Metadata, error)) {
	fake.getCargoMetadataIfNeededMutex.Lock()
	defer fake.getCargoMetadataIfNeededMutex.Unlock()
	fake.GetCargoMetadataIfNeededStub = stub
}

func (fake *FakeCargoImplementation) GetCargoMetadataIfNeededArgsForCall(i int) (*cargo.Mod, string) {
	fake.getCargoMetadataIfNeededMutex.RLock()
	defer fake.getCargoMetadataIfNeededMutex.RUnlock()
	argsForCall := fake.getCargoMetadataIfNeededArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCargoImplementation) GetCargoMetadataIfNeededReturns(result1 *cargo.Metadata, result2 error) {
	fake.getCargoMetadataIfNeededMutex.Lock()
	defer fake.getCargoMetadataIfNeededMutex.Unlock()
	fake.GetCargoMetadataIfNeededStub = nil
	fake.getCargoMetadataIfNeededReturns = struct {
		result1 *cargo.Metadata
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) GetCargoMetadataIfNeededReturnsOnCall(i int, result1 *cargo.Metadata, result2 error) {
	fake.getCargoMetadataIfNeededMutex.Lock()
	defer fake.getCargoMetadataIfNeededMutex.Unlock()
	fake.GetCargoMetadataIfNeededStub = nil
	if fake.getCargoMetadataIfNeededReturnsOnCall == nil {
		fake.getCargoMetadataIfNeededReturnsOnCall = make(map[int]struct {
			result1 *cargo.Metadata
			result2 error
		})
	}
	fake.getCargoMetadataIfNeededReturnsOnCall[i] = struct {
		result1 *cargo.Metadata
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) GetPackageDependencies(arg1 *cargo.Metadata, arg2 string) ([]*cargo.Package, error) {
	fake.getPackageDependenciesMutex.Lock()
	ret, specificReturn := fake.getPackageDependenciesReturnsOnCall[len(fake.getPackageDependenciesArgsForCall)]
	fake.getPackageDependenciesArgsForCall = append(fake.getPackageDependenciesArgsForCall, struct {
		arg1 *cargo.Metadata
		arg2 string
	}{arg1, arg2})
	stub := fake.GetPackageDependenciesStub
	fakeReturns := fake.getPackageDependenciesReturns
	fake.recordInvocation("GetPackageDependencies", []interface{}{arg1, arg2})
	fake.getPackageDependenciesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCargoImplementation) GetPackageDependenciesCallCount() int {
	fake.getPackageDependenciesMutex.RLock()
	defer fake.getPackageDependenciesMutex.RUnlock()
	return len(fake.getPackageDependenciesArgsForCall)
}

func (fake *FakeCargoImplementation) GetPackageDependenciesCalls(stub func(*cargo.Metadata, string) ([]*cargo.Package, error)) {
	fake.getPackageDependenciesMutex.Lock()
	defer fake.getPackageDependenciesMutex.Unlock()
	fake.GetPackageDependenciesStub = stub
}

func (fake *FakeCargoImplementation) GetPackageDependenciesArgsForCall(i int) (*cargo.Metadata, string) {
	fake.getPackageDependenciesMutex.RLock()
	defer fake.getPackageDependenciesMutex.RUnlock()
	argsForCall := fake.getPackageDependenciesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCargoImplementation) GetPackageDependenciesReturns(result1 []*cargo.Package, result2 error) {
	fake.getPackageDependenciesMutex.Lock()
	defer fake.getPackageDependenciesMutex.Unlock()
	fake.GetPackageDependenciesStub = nil
	fake.getPackageDependenciesReturns = struct {
		result1 []*cargo.Package
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) GetPackageDependenciesReturnsOnCall(i int, result1 []*cargo.Package, result2 error) {
	fake.getPackageDependenciesMutex.Lock()
	defer fake.getPackageDependenciesMutex.Unlock()
	fake.GetPackageDependenciesStub = nil
	if fake.getPackageDependenciesReturnsOnCall == nil {
		fake.getPackageDependenciesReturnsOnCall = make(map[int]struct {
			result1 []*cargo.Package
			result2 error
		})
	}
	fake.getPackageDependenciesReturnsOnCall[i] = struct {
		result1 []*cargo.Package
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) GetRootModule(arg1 *cargo.Metadata, arg2 string) (meta.Package, error) {
	fake.getRootModuleMutex.Lock()
	ret, specificReturn := fake.getRootModuleReturnsOnCall[len(fake.getRootModuleArgsForCall)]
	fake.getRootModuleArgsForCall = append(fake.getRootModuleArgsForCall, struct {
		arg1 *cargo.Metadata
		arg2 string
	}{arg1, arg2})
	stub := fake.GetRootModuleStub
	fakeReturns := fake.getRootModuleReturns
	fake.recordInvocation("GetRootModule", []interface{}{arg1, arg2})
	fake.getRootModuleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCargoImplementation) GetRootModuleCallCount() int {
	fake.getRootModuleMutex.RLock()
	defer fake.getRootModuleMutex.RUnlock()
	return len(fake.getRootModuleArgsForCall)
}

func (fake *FakeCargoImplementation) GetRootModuleCalls(stub func(*cargo.Metadata, string) (meta.Package, error)) {
	fake.getRootModuleMutex.Lock()
	defer fake.getRootModuleMutex.Unlock()
	fake.GetRootModuleStub = stub
}

func (fake *FakeCargoImplementation) GetRootModuleArgsForCall(i int) (*cargo.Metadata, string) {
	fake.getRootModuleMutex.RLock()
	defer fake.getRootModuleMutex.RUnlock()
	argsForCall := fake.getRootModuleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCargoImplementation) GetRootModuleReturns(result1 meta.Package, result2 error) {
	fake.getRootModuleMutex.Lock()
	defer fake.getRootModuleMutex.Unlock()
	fake.GetRootModuleStub = nil
	fake.getRootModuleReturns = struct {
		result1 meta.Package
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) GetRootModuleReturnsOnCall(i int, result1 meta.Package, result2 error) {
	fake.getRootModuleMutex.Lock()
	defer fake.getRootModuleMutex.Unlock()
	fake.GetRootModuleStub = nil
	if fake.getRootModuleReturnsOnCall == nil {
		fake.getRootModuleReturnsOnCall = make(map[int]struct {
			result1 meta.Package
			result2 error
		})
	}
	fake.getRootModuleReturnsOnCall[i] = struct {
		result1 meta.Package
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) GetRootProjectName(arg1 string) (string, error) {
	fake.getRootProjectNameMutex.Lock()
	ret, specificReturn := fake.getRootProjectNameReturnsOnCall[len(fake.getRootProjectNameArgsForCall)]
	fake.getRootProjectNameArgsForCall = append(fake.getRootProjectNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetRootProjectNameStub
	fakeReturns := fake.getRootProjectNameReturns
	fake.recordInvocation("GetRootProjectName", []interface{}{arg1})
	fake.getRootProjectNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCargoImplementation) GetRootProjectNameCallCount() int {
	fake.getRootProjectNameMutex.RLock()
	defer fake.getRootProjectNameMutex.RUnlock()
	return len(fake.getRootProjectNameArgsForCall)
}

func (fake *FakeCargoImplementation) GetRootProjectNameCalls(stub func(string) (string, error)) {
	fake.getRootProjectNameMutex.Lock()
	defer fake.getRootProjectNameMutex.Unlock()
	fake.GetRootProjectNameStub = stub
}

func (fake *FakeCargoImplementation) GetRootProjectNameArgsForCall(i int) string {
	fake.getRootProjectNameMutex.RLock()
	defer fake.getRootProjectNameMutex.RUnlock()
	argsForCall := fake.getRootProjectNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCargoImplementation) GetRootProjectNameReturns(result1 string, result2 error) {
	fake.getRootProjectNameMutex.Lock()
	defer fake.getRootProjectNameMutex.Unlock()
	fake.GetRootProjectNameStub = nil
	fake.getRootProjectNameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) GetRootProjectNameReturnsOnCall(i int, result1 string, result2 error) {
	fake.getRootProjectNameMutex.Lock()
	defer fake.getRootProjectNameMutex.Unlock()
	fake.GetRootProjectNameStub = nil
	if fake.getRootProjectNameReturnsOnCall == nil {
		fake.getRootProjectNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getRootProjectNameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) PopulateDependencies(arg1 *cargo.Metadata, arg2 *meta.Package, arg3 bool, arg4 *map[string]*meta.Package) error {
	fake.populateDependenciesMutex.Lock()
	ret, specificReturn := fake.populateDependenciesReturnsOnCall[len(fake.populateDependenciesArgsForCall)]
	fake.populateDependenciesArgsForCall = append(fake.populateDependenciesArgsForCall, struct {
		arg1 *cargo.Metadata
		arg2 *meta.Package
		arg3 bool
		arg4 *map[string]*meta.Package
	}{arg1, arg2, arg3, arg4})
	stub := fake.PopulateDependenciesStub
	fakeReturns := fake.populateDependenciesReturns
	fake.recordInvocation("PopulateDependencies", []interface{}{arg1, arg2, arg3, arg4})
	fake.populateDependenciesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCargoImplementation) PopulateDependenciesCallCount() int {
	fake.populateDependenciesMutex.RLock()
	defer fake.populateDependenciesMutex.RUnlock()
	return len(fake.populateDependenciesArgsForCall)
}

func (fake *FakeCargoImplementation) PopulateDependenciesCalls(stub func(*cargo.Metadata, *meta.Package, bool, *map[string]*meta.Package) error) {
	fake.populateDependenciesMutex.Lock()
	defer fake.populateDependenciesMutex.Unlock()
	fake.PopulateDependenciesStub = stub
}

func (fake *FakeCargoImplementation) PopulateDependenciesArgsForCall(i int) (*cargo.Metadata, *meta.Package, bool, *map[string]*meta.Package) {
	fake.populateDependenciesMutex.RLock()
	defer fake.populateDependenciesMutex.RUnlock()
	argsForCall := fake.populateDependenciesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCargoImplementation) PopulateDependenciesReturns(result1 error) {
	fake.populateDependenciesMutex.Lock()
	defer fake.populateDependenciesMutex.Unlock()
	fake.PopulateDependenciesStub = nil
	fake.populateDependenciesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCargoImplementation) PopulateDependenciesReturnsOnCall(i int, result1 error) {
	fake.populateDependenciesMutex.Lock()
	defer fake.populateDependenciesMutex.Unlock()
	fake.PopulateDependenciesStub = nil
	if fake.populateDependenciesReturnsOnCall == nil {
		fake.populateDependenciesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.populateDependenciesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCargoImplementation) ReadConfig(arg1 string) (*cargo.Config, error) {
	fake.readConfigMutex.Lock()
	ret, specificReturn := fake.readConfigReturnsOnCall[len(fake.readConfigArgsForCall)]
	fake.readConfigArgsForCall = append(fake.readConfigArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadConfigStub
	fakeReturns := fake.readConfigReturns
	fake.recordInvocation("ReadConfig", []interface{}{arg1})
	fake.readConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCargoImplementation) ReadConfigCallCount() int {
	fake.readConfigMutex.RLock()
	defer fake.readConfigMutex.RUnlock()
	return len(fake.readConfigArgsForCall)
}

func (fake *FakeCargoImplementation) ReadConfigCalls(stub func(string) (*cargo.Config, error)) {
	fake.readConfigMutex.Lock()
	defer fake.readConfigMutex.Unlock()
	fake.ReadConfigStub = stub
}

func (fake *FakeCargoImplementation) ReadConfigArgsForCall(i int) string {
	fake.readConfigMutex.RLock()
	defer fake.readConfigMutex.RUnlock()
	argsForCall := fake.readConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCargoImplementation) ReadConfigReturns(result1 *cargo.Config, result2 error) {
	fake.readConfigMutex.Lock()
	defer fake.readConfigMutex.Unlock()
	fake.ReadConfigStub = nil
	fake.readConfigReturns = struct {
		result1 *cargo.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) ReadConfigReturnsOnCall(i int, result1 *cargo.Config, result2 error) {
	fake.readConfigMutex.Lock()
	defer fake.readConfigMutex.Unlock()
	fake.ReadConfigStub = nil
	if fake.readConfigReturnsOnCall == nil {
		fake.readConfigReturnsOnCall = make(map[int]struct {
			result1 *cargo.Config
			result2 error
		})
	}
	fake.readConfigReturnsOnCall[i] = struct {
		result1 *cargo.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) ReadLockFile(arg1 string) (*cargo.LockFile, error) {
	fake.readLockFileMutex.Lock()
	ret, specificReturn := fake.readLockFileReturnsOnCall[len(fake.readLockFileArgsForCall)]
	fake.readLockFileArgsForCall = append(fake.readLockFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadLockFileStub
	fakeReturns := fake.readLockFileReturns
	fake.recordInvocation("ReadLockFile", []interface{}{arg1})
	fake.readLockFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCargoImplementation) ReadLockFileCallCount() int {
	fake.readLockFileMutex.RLock()
	defer fake.readLockFileMutex.RUnlock()
	return len(fake.readLockFileArgsForCall)
}

func (fake *FakeCargoImplementation) ReadLockFileCalls(stub func(string) (*cargo.LockFile, error)) {
	fake.readLockFileMutex.Lock()
	defer fake.readLockFileMutex.Unlock()
	fake.ReadLockFileStub = stub
}

func (fake *FakeCargoImplementation) ReadLockFileArgsForCall(i int) string {
	fake.readLockFileMutex.RLock()
	defer fake.readLockFileMutex.RUnlock()
	argsForCall := fake.readLockFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCargoImplementation) ReadLockFileReturns(result1 *cargo.LockFile, result2 error) {
	fake.readLockFileMutex.Lock()
	defer fake.readLockFileMutex.Unlock()
	fake.ReadLockFileStub = nil
	fake.readLockFileReturns = struct {
		result1 *cargo.LockFile
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) ReadLockFileReturnsOnCall(i int, result1 *cargo.LockFile, result2 error) {
	fake.readLockFileMutex.Lock()
	defer fake.readLockFileMutex.Unlock()
	fake.ReadLockFileStub = nil
	if fake.readLockFileReturnsOnCall == nil {
		fake.readLockFileReturnsOnCall = make(map[int]struct {
			result1 *cargo.LockFile
			result2 error
		})
	}
	fake.readLockFileReturnsOnCall[i] = struct {
		result1 *cargo.LockFile
		result2 error
	}{result1, result2}
}

func (fake *FakeCargoImplementation) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.convertCargoPackageToMetaPackageMutex.RLock()
	defer fake.convertCargoPackageToMetaPackageMutex.RUnlock()
	fake.convertPackagesToModulesListMutex.RLock()
	defer fake.convertPackagesToModulesListMutex.RUnlock()
	fake.getCargoMetadataMutex.RLock()
	defer fake.getCargoMetadataMutex.RUnlock()
	fake.getCargoMetadataIfNeededMutex.RLock()
	defer fake.getCargoMetadataIfNeededMutex.RUnlock()
	fake.getPackageDependenciesMutex.RLock()
	defer fake.getPackageDependenciesMutex.RUnlock()
	fake.getRootModuleMutex.RLock()
	defer fake.getRootModuleMutex.RUnlock()
	fake.getRootProjectNameMutex.RLock()
	defer fake.getRootProjectNameMutex.RUnlock()
	fake.populateDependenciesMutex.RLock()
	defer fake.populateDependenciesMutex.RUnlock()
	fake.readConfigMutex.RLock()
	defer fake.readConfigMutex.RUnlock()
	fake.readLockFileMutex.RLock()
	defer fake.readLockFileMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCargoImplementation) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
